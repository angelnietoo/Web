<!doctype html>
<html lang="es">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Ejercicio 4 — procesarTareas</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            font-family: system-ui, Arial;
            padding: 16px;
            background: #f7fafc
        }

        .card {
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e6eef3;
            max-width: 900px
        }

        textarea {
            width: 100%;
            height: 100px;
            padding: 8px;
            font-family: monospace;
            margin-top: 8px
        }

        button {
            margin-top: 8px;
            padding: 8px 12px
        }

        pre {
            background: #0b1220;
            color: #e6eef8;
            padding: 10px;
            border-radius: 6px;
            min-height: 120px;
            overflow: auto
        }
    </style>
</head>

<body>
    <div class="card">
        <h2>Ejercicio 4 — procesarTareas (callbacks)</h2>
        <p>Introduce JSON: array de tareas {id, duracion(ms)}. El procesamiento simula asincronía con setTimeout.</p>
        <textarea id="tasks">[{"id":"A","duracion":300},{"id":"B","duracion":100},{"id":"C","duracion":200}]</textarea>
        <div style="display:flex;gap:8px">
            <button id="run">Iniciar</button>
            <button id="clear">Limpiar salida</button>
        </div>
        <h3>Salida</h3>
        <pre id="out"></pre>
    </div>

    <script>
        /*
          procesarTareas(tareas, callbackFinal, onProgress)
          - Ejecuta cada tarea "en paralelo" usando setTimeout con la duración indicada.
          - Cuando una tarea termina hace log y, cuando todas terminan, llama a callbackFinal con el orden real de finalización.
          - onProgress es opcional y se llama por cada tarea completada.
        */
        function procesarTareas(tareas, callbackFinal, onProgress) {
            if (!Array.isArray(tareas)) throw new TypeError('tareas debe ser un array');
            const completadas = [];
            let pendientes = tareas.length;
            if (pendientes === 0) { callbackFinal(completadas); return; }
            tareas.forEach(t => {
                const id = t.id;
                const dur = Math.max(0, Number(t.duracion) || 0);
                setTimeout(() => {
                    append(`Tarea ${id} completada (dur ${dur} ms)`);
                    completadas.push(id);
                    if (typeof onProgress === 'function') onProgress(id, dur);
                    pendientes--;
                    if (pendientes === 0) callbackFinal(completadas);
                }, dur);
            });
        }

        /*
          append(s)
          - Añade una línea al área de salida y mantiene el scroll abajo para ver la última línea.
        */
        function append(s) { out.textContent += s + '\n'; out.scrollTop = out.scrollHeight; }

        /*
          clearOut()
          - Limpia el área de salida; útil para reiniciar la prueba sin recargar la página.
        */
        function clearOut() { out.textContent = ''; }

        const out = document.getElementById('out');

        document.getElementById('run').addEventListener('click', () => {
            clearOut();
            let tareas;
            try { tareas = JSON.parse(document.getElementById('tasks').value); if (!Array.isArray(tareas)) throw new Error('No es array'); }
            catch (e) { append('JSON inválido: ' + e.message); return; }
            append('Iniciando procesamiento: ' + JSON.stringify(tareas));
            procesarTareas(tareas, resultadoFinal => {
                append('Todas completadas. Resultado final: ' + JSON.stringify(resultadoFinal));
            });
        });

        document.getElementById('clear').addEventListener('click', clearOut);
    </script>
</body>

</html>